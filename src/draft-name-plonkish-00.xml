<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.29 (Ruby 3.4.3) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>


<rfc ipr="trust200902" category="info" submissionType="IETF">
  <front>
    <title>Specification of the Plonkish Relation</title>

    <author initials="F." surname="(Insert-Author-Name-here;-bug-707)" fullname="Firstname (Insert-Author-Name-here;-bug-707)">
      <organization>(Insert Author affiliation here)</organization>
      <address>
      </address>
    </author>

    <date year="2025" month="June" day="03"/>

    
    
    

    <abstract>


<?line 34?>

<t>An arithmetisation is a language that a proof system uses to express statements. A circuit is a program in this language. The associated computation has been computed correctly if and only if all of the constraints in the circuit are satisified.</t>

<t>The primary purpose of this document is to specify a particular arithmetisation: the "Plonkish" arithmetisation used in the Halo 2 proving system.</t>



    </abstract>



  </front>

  <middle>


<?line 40?>

<section anchor="introduction"><name>Introduction</name>

<t>This document describes the general Plonkish relation used in zero-knowledge proof systems. It is based on ideas in <xref target="Thomas22"/> and is intended to be read alongside implementation-focused material.</t>

</section>
<section anchor="dependencies-and-notation"><name>Dependencies and Notation</name>

<t>Plonkish arithmetization depends on a scalar field over a prime modulus <spanx style="verb">p</spanx>. We represent this field as the object <spanx style="verb">Fp</spanx>. We denote the additive identity by <spanx style="verb">0</spanx> and the multiplicative identity by <spanx style="verb">1</spanx>. Integers, taken modulo the field modulus <spanx style="verb">p</spanx>, are called scalars; arithmetic operations on scalars are implicitly performed modulo <spanx style="verb">p</spanx>. We denote the sum, difference, and product of two scalars using the <spanx style="verb">+</spanx>, <spanx style="verb">-</spanx>, and <spanx style="verb">*</spanx> operators, respectively.</t>

<t>The notation <spanx style="verb">a..b</spanx> means the sequence of integers from <spanx style="verb">a</spanx> (inclusive) to <spanx style="verb">b</spanx> (exclusive) in ascending order. <spanx style="verb">[a, b)</spanx> means the corresponding set of integers.</t>

<t>The length of a sequence <spanx style="verb">S</spanx>, or the number of elements in a set <spanx style="verb">S</spanx>, is written <spanx style="verb">#S</spanx>.</t>

<t><spanx style="verb">{ f(e) : e in S }</spanx> means the set of evaluations of <spanx style="verb">f</spanx> on the set <spanx style="verb">S</spanx>.</t>

<t><spanx style="verb">[f(e) : e &lt;- a..b]</spanx> means the sequence of evaluations of <spanx style="verb">f</spanx> on <spanx style="verb">a..b</spanx>.</t>

<t><spanx style="verb">[Aₑ]ₑ</spanx> means the sequence of <spanx style="verb">Aₑ</spanx> for some implicitly defined sequence of indices <spanx style="verb">e</spanx>.</t>

<t>When <spanx style="verb">f</spanx> is a function that takes a tuple as argument, we will allow <spanx style="verb">f((i, j))</spanx> to be written as <spanx style="verb">f[i, j]</spanx>.</t>

<t>The terminology used here is intended to be consistent with <xref target="ZKProofCommunityReference"/>. We diverge from this terminology as follows:
* We refer to the public inputs to the circuit as an "instance vector". The entries of this vector are called "instance variables" in the Community Reference.</t>

</section>
<section anchor="the-general-plonkish-relation-rplonkish"><name>The General Plonkish Relation <spanx style="verb">R_plonkish</spanx></name>

<t>The general relation <spanx style="verb">R_plonkish</spanx> contains pairs of <spanx style="verb">(x, w)</spanx> where:
* the instance <spanx style="verb">x</spanx> consists of the parameters of the proof system, the circuit <spanx style="verb">C</spanx>, and the public inputs to the circuit (i.e. the instance vector).
* the witness <spanx style="verb">w</spanx> consists of the matrix of values provided by the prover. In this model it consists of the (potentially private) prover inputs to the circuit, and any intermediate values (including fixed values) that are not inputs to the circuit but are required in order to satisfy it.</t>

<t>We say that a <spanx style="verb">x</spanx> is a <em>valid</em> instance whenever there exists some witness <spanx style="verb">w</spanx> such that <spanx style="verb">(x, w) in R_plonkish</spanx> holds.
The Plonkish language <spanx style="verb">L_plonkish</spanx> contains all valid instances.</t>

<t>A circuit-specific relation is a specialization of <spanx style="verb">R_plonkish</spanx> to a particular circuit.</t>

<t>If the proof system is knowledge sound, then the prover must have knowledge of the witness in order to construct a valid proof. If it is also zero knowledge, then witness entries can be private, and an honestly generated proof leaks no information about the private inputs to the circuit beyond the fact that it was obtained with knowledge of some satisfying witness.</t>

<section anchor="instances"><name>Instances</name>
<t>The relation <spanx style="verb">R_plonkish</spanx> takes instances of the following form:</t>

<texttable>
      <ttcol align='left'>Instance element</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">Fp</spanx></c>
      <c>A prime field.</c>
      <c><spanx style="verb">C</spanx></c>
      <c>The circuit.</c>
      <c><spanx style="verb">phi</spanx></c>
      <c>The instance vector <spanx style="verb">phi : Fp^(C.t)</spanx> (where <spanx style="verb">t</spanx> is the instance vector length defined below).</c>
</texttable>

<t>The circuit <spanx style="verb">C : AbstractCircuit_Fp</spanx> in turn has the following form:</t>

<texttable>
      <ttcol align='left'>Circuit element</ttcol>
      <ttcol align='left'>Description</ttcol>
      <ttcol align='left'>Used in</ttcol>
      <c><spanx style="verb">t</spanx></c>
      <c>Length of the instance vector.</c>
      <c>&#160;</c>
      <c><spanx style="verb">n &gt; 0</spanx></c>
      <c>Number of rows for the witness matrix.</c>
      <c>&#160;</c>
      <c><spanx style="verb">m &gt; 0</spanx></c>
      <c>Number of columns for the witness matrix.</c>
      <c>&#160;</c>
      <c><spanx style="verb">≡</spanx></c>
      <c>An equivalence relation on <spanx style="verb">[0,m) x [0,n)</spanx>, indicating which witness entries are equal to each other.</c>
      <c><xref target="copy-constraints">Copy constraints</xref></c>
      <c><spanx style="verb">S</spanx></c>
      <c>A set <spanx style="verb">S ⊆ ([0,m) x [0,n)) x [0,t)</spanx>, indicating which witness entries are equal to instance vector entries.</c>
      <c><xref target="copy-constraints">Copy constraints</xref></c>
      <c><spanx style="verb">m_f &lt;= m</spanx></c>
      <c>Number of columns that are fixed.</c>
      <c><xref target="fixed-constraints">Fixed constraints</xref></c>
      <c><spanx style="verb">f</spanx></c>
      <c>The fixed content of the first <spanx style="verb">m_f</spanx> columns, <spanx style="verb">f : Fp^(m_f x n)</spanx>.</c>
      <c><xref target="fixed-constraints">Fixed constraints</xref></c>
      <c><spanx style="verb">p_u</spanx></c>
      <c>Custom multivariate polynomials <spanx style="verb">p_u : Fp^m -&gt; Fp</spanx>.</c>
      <c><xref target="custom-constraints">Custom constraints</xref></c>
      <c><spanx style="verb">CUS_u</spanx></c>
      <c>Sets <spanx style="verb">CUS_u ⊆ [0,n)</spanx>, indicating rows on which the custom polynomials <spanx style="verb">p_u</spanx> are constrained to evaluate to <spanx style="verb">0</spanx>.</c>
      <c><xref target="custom-constraints">Custom constraints</xref></c>
      <c><spanx style="verb">L_v</spanx></c>
      <c>Number of table columns in the lookup table with index <spanx style="verb">v, TAB_v</spanx>.</c>
      <c><xref target="lookup-constraints">Lookup constraints</xref></c>
      <c><spanx style="verb">TAB_v</spanx></c>
      <c>Lookup tables <spanx style="verb">TAB_v ⊆ Fp^{L_v}</spanx>, each with a number of tuples in <spanx style="verb">Fp^{L_v}</spanx>.</c>
      <c><xref target="lookup-constraints">Lookup constraints</xref></c>
      <c><spanx style="verb">q_{v,s}</spanx></c>
      <c>Scaling multivariate polynomials <spanx style="verb">q_{v,s} : Fp^m -&gt; Fp</spanx> for <spanx style="verb">s in 0..L_v</spanx>.</c>
      <c><xref target="lookup-constraints">Lookup constraints</xref></c>
      <c><spanx style="verb">LOOK_v</spanx></c>
      <c>Sets <spanx style="verb">LOOK_v ⊆ [0,n)</spanx>, indicating rows on which the scaling polynomials <spanx style="verb">q_{v,s}</spanx> evaluate to some tuple in <spanx style="verb">TAB_v</spanx>.</c>
      <c><xref target="lookup-constraints">Lookup constraints</xref></c>
</texttable>

</section>
<section anchor="witnesses"><name>Witnesses</name>

<t>The relation <spanx style="verb">R_plonkish</spanx> takes witnesses of the following form:</t>

<texttable>
      <ttcol align='left'>Witness element</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">w</spanx></c>
      <c>The witness matrix <spanx style="verb">w : Fp^(m x n)</spanx>.</c>
</texttable>

<t>Define <spanx style="verb">w_j</spanx> as the row vector <spanx style="verb">[ w[i, j] : i &lt;- 0..m ]</spanx>.</t>

</section>
<section anchor="definition-of-the-relation"><name>Definition of the relation</name>

<t>Given the above definitions, the relation <spanx style="verb">R_plonkish</spanx> corresponds to a set of (instance, witness) pairs:</t>

<t><list style="symbols">
  <t><spanx style="verb">x</spanx>:
  <list style="symbols">
      <t><spanx style="verb">Fp</spanx></t>
      <t><spanx style="verb">C</spanx>:
      <list style="symbols">
          <t><spanx style="verb">t</spanx>, <spanx style="verb">n</spanx>, <spanx style="verb">m</spanx>, <spanx style="verb">≡</spanx>, <spanx style="verb">S</spanx>, <spanx style="verb">m_f</spanx>, <spanx style="verb">f</spanx></t>
          <t><spanx style="verb">[ (p_u, CUS_u) ]_u</spanx></t>
          <t><spanx style="verb">[ (L_v, TAB_v, [q_{v,s}]_s, LOOK_v) ]_v</spanx></t>
        </list></t>
      <t><spanx style="verb">phi</spanx></t>
    </list></t>
  <t><spanx style="verb">w</spanx></t>
</list></t>

<t>such that:</t>

<texttable>
      <ttcol align='left'>Domains</ttcol>
      <ttcol align='left'>Constraints</ttcol>
      <c><spanx style="verb">w : Fp^(m × n)</spanx>, <spanx style="verb">f : Fp^(m_f × n)</spanx></c>
      <c><spanx style="verb">i in [0, m_f), j in [0, n) =&gt; w[i, j] = f[i, j]</spanx></c>
      <c><spanx style="verb">S ⊆ ([0, m) x [0, n)) x [0, t)</spanx>, <spanx style="verb">phi : Fp^t</spanx></c>
      <c><spanx style="verb">((i, j), k) in S =&gt; w[i, j] = phi[k]</spanx></c>
      <c><spanx style="verb">≡ ⊆ ([0, m) x [0, n)) x ([0, m) × [0, n))</spanx></c>
      <c><spanx style="verb">(i, j) ≡ (k, l) =&gt; w[i, j] = w[k, l]</spanx></c>
      <c><spanx style="verb">CUS_u ⊆ [0, n)</spanx>, <spanx style="verb">p_u : Fp^m -&gt; Fp</spanx></c>
      <c><spanx style="verb">j in CUS_u =&gt; p_u(w_j) = 0</spanx></c>
      <c><spanx style="verb">LOOK_v ⊆ [0, n)</spanx>, <spanx style="verb">q_{v,s} : Fp^m -&gt; Fp</spanx>, <spanx style="verb">TAB_v ⊆ Fp^{L_v}</spanx></c>
      <c><spanx style="verb">j in LOOK_v =&gt; [ q_{v,s}(w_j) : s &lt;- 0..L_v ] in TAB_v</spanx></c>
</texttable>

<t>In this model, a circuit-specific relation <spanx style="verb">R_{Fp, C}</spanx> for a field <spanx style="verb">Fp</spanx> and circuit <spanx style="verb">C</spanx> is the relation <spanx style="verb">R_plonkish</spanx> restricted to <spanx style="verb">( (Fp, C, phi : Fp^C.t), w : Fp^(C.m × C.n))</spanx></t>

</section>
<section anchor="conditions-satisfied-by-statements-in-rplonkish"><name>Conditions satisfied by statements in <spanx style="verb">R_plonkish</spanx></name>

<t>There are four types of constraints that a Plonkish statement <spanx style="verb">(x, w) in R_plonkish</spanx> must satisfy:
* Fixed constraints
* Copy constraints
* Custom constraints
* Lookup constraints</t>

<section anchor="fixed-constraints"><name>Fixed constraints</name>

<t>The first <spanx style="verb">m_f</spanx> columns of <spanx style="verb">w</spanx> are fixed to the columns of <spanx style="verb">f</spanx>.</t>

</section>
<section anchor="copy-constraints"><name>Copy constraints</name>

<t>Copy constraints enforce that entries in the witness matrix are equal to each other, or that an instance entry is equal to a witness entry.</t>

<texttable>
      <ttcol align='left'>Copy Constraints</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">((i,j),k) in S =&gt; w[i, j] = phi[k]</spanx></c>
      <c>The <spanx style="verb">(i,j)</spanx> advice entry is equal to the <spanx style="verb">k</spanx> instance entry for all <spanx style="verb">((i,j),k) in S</spanx>.</c>
      <c><spanx style="verb">(i,j) ≡ (k,l) =&gt; w[i, j] = w[k, l]</spanx></c>
      <c><spanx style="verb">≡</spanx> is an equivalence relation indicating which witness entries are constrained to be equal.</c>
</texttable>

<t>By convention, when fixed abstract cells have the same value, we consider them to be equivalent under <spanx style="verb">≡</spanx>. That is, if <spanx style="verb">i &lt; m_f &amp;&amp; k &lt; m_f &amp;&amp; f[i, j] = f[k, l]</spanx> then <spanx style="verb">(i, j) ≡ (k, l)</spanx>.</t>

<t>This has no direct effect on the relation, but it will simplify expressing an optimization.</t>

</section>
<section anchor="custom-constraints"><name>Custom constraints</name>

<t>Plonkish also allows custom constraints between the witness matrix entries. In the abstract model we are defining, a custom constraint applies only within a single row of the witness matrix, for the rows that are selected for that constraint.</t>

<t>In some systems using Plonkish, custom constraints are referred to as "gates".</t>

<t>Custom constraints enforce that witness entries within a row satisfy some multivariate polynomial. Here <spanx style="verb">p_u</spanx> could indicate any case that can be generated using a combination of multiplications and additions.</t>

<texttable>
      <ttcol align='left'>Custom Constraints</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">j in CUS_u =&gt; p_u(w_j) = 0</spanx></c>
      <c><spanx style="verb">u</spanx> is the index of a custom constraint. <spanx style="verb">j</spanx> ranges over the set of rows <spanx style="verb">CUS_u</spanx> for which the custom constraint is switched on.</c>
</texttable>

<t>Here <spanx style="verb">p_u : Fp^m -&gt; Fp</spanx> is an arbitrary <eref target="https://en.wikipedia.org/wiki/Polynomial_ring#Definition_(multivariate_case)">multivariate polynomial</eref>:</t>

<ul empty="true"><li>
  <t>Given <spanx style="verb">η</spanx> symbols <spanx style="verb">X_0, ..., X_{η−1}</spanx> called indeterminates, a multivariate polynomial <spanx style="verb">P</spanx> in these indeterminates with coefficients in <spanx style="verb">Fp</spanx> is a finite linear combination:</t>

  <t><spanx style="verb">P(X_0, ..., X_{η−1}) = Σ_{z=0}^{ν−1} (c_z · Π_{b=0}^{η−1} X_b^{α_{z,b}})</spanx></t>

  <t>where  <spanx style="verb">c_z in Fp</spanx>, <spanx style="verb">c_z neq 0</spanx>, and <spanx style="verb">ν</spanx> and <spanx style="verb">α_{z,b}</spanx> are positive integers.</t>
</li></ul>

</section>
<section anchor="lookup-constraints"><name>Lookup constraints</name>

<t>Lookup constraints enforce that some polynomial function of the witness entries on a row are contained in some table.</t>

<t>The sizes of tables are not limited at this layer. A realization of a proving system using Plonkish arithmetization may limit the supported size of tables, possibly depending on <spanx style="verb">n</spanx>, or it may have some way to compile larger tables.</t>

<t>In this specification, we only support fixed lookup tables determined in advance. This could be generalized to support dynamic tables determined by part of the witness matrix.</t>

<texttable>
      <ttcol align='left'>Lookup Constraints</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">j in LOOK_v =&gt; [ q_{v,s}(w_j) : s &lt;- 0 .. L_v ] in TAB_v</spanx></c>
      <c><spanx style="verb">v</spanx> is the index of a lookup table. <spanx style="verb">j</spanx> ranges over the set of rows <spanx style="verb">LOOK_v</spanx> for which the lookup constraint is switched on.</c>
</texttable>

<t>Here <spanx style="verb">q_{v,s} : Fp^m -&gt; Fp</spanx> for <spanx style="verb">s &lt;- 0 .. L_v</spanx> are multivariate polynomials that collectively map the witness entries <spanx style="verb">w_j</spanx> on the lookup row <spanx style="verb">j in LOOK_v</spanx> to a tuple of field elements. This tuple will be constrained to match some row of the table <spanx style="verb">TAB_v</spanx>.</t>

</section>
</section>
</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>This document has no actions for IANA.</t>

</section>


  </middle>

  <back>




    <references title='Informative References' anchor="sec-informative-references">

<reference anchor="Thomas22" target="https://eprint.iacr.org/2022/777">
  <front>
    <title>Arithmetization of Sigma relations in Halo 2</title>
    <author initials="M." surname="Thomas" fullname="Morgan Thomas">
      <organization></organization>
    </author>
    <date year="2022"/>
  </front>
  <seriesInfo name="IACR" value="ePrint Archive 2022/777"/>
  <format type="HTML" target="https://eprint.iacr.org/2022/777"/>
</reference>
<reference anchor="ZKProofCommunityReference" target="https://docs.zkproof.org/reference">
  <front>
    <title>ZKProof Community Reference</title>
    <author >
      <organization>ZKProof Community</organization>
    </author>
    <date year="2023"/>
  </front>
  <format type="HTML" target="https://docs.zkproof.org/reference"/>
</reference>


    </references>



<?line 206?>

<section anchor="acknowledgements"><name>Acknowledgements</name>

<t>Firstname Lastname, Firstname Lastname.</t>

</section>


  </back>

<!-- ##markdown-source:
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
MQAA

-->

</rfc>

